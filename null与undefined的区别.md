# null与undefined的区别
* 在阅读了阮老师的博客后，对null以及undefined有了一个新的认识。
``` javascript
var a = undefined;
var a = null;
undefined == null
// true
```
别的语言只会存在一个null,但是为什么在Javascript中，我们会遇到两个代表“空”的东西呢！<br/>
* JavaScript的<b>最初版本</b>是这样区分的：<b>null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。</b>
``` javascript
Number(undefined)
// NaN

5 + undefined
// NaN
```
* 目前的用法。
<b>null表示"没有对象"，即该处不应该有值。</b>典型用法是
``` javascript
（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。

Object.getPrototypeOf(Object.prototype)
// null
```
<b>undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。</b>典型用法是:
``` javascript
（1）变量被声明了，但没有赋值时，就等于undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
（3）对象没有赋值的属性，该属性的值为undefined。
（4）函数没有返回值时，默认返回undefined。

var i;
i // undefined

function f(x){console.log(x)}
f() // undefined

var  o = new Object();
o.p // undefined

var x = f();
x // undefined
```
# 闭包的一些问题？？
## 1. 绕不开的闭包问题 <br/>
在学js的时候，总是在网上会看见一些闭包是什么？怎么样才能够真正的理解闭包？在看了许许多多的文章之后，我也算是弄明白了这些“有趣”的问题。<br/>
## 2. 作用域<br/>
在学习闭包问题之前，我们有必要搞明白一个问题作用域是什么？以及函数作用域和块作用域又是什么？
## 2.1 编译原理
在编程中我们通过操作变量并且存贮它们访问他们，最终形成了程序的状态。好吧，说的有点复杂。转到我们的正题上来，JS是一门编译语言。它不是提前编译的，因此它不能在分布式系统中移植。我们要做什么呢？那就是分析一下它的编译过程，这对我们之后理解作用域，以及变量提升等等问题有诸多的帮助。<br/>

举个栗子：
``` javascript
var a = 1
```
程序在执行之前会经历三个步骤：1.分词/词法分析(二者稍微有点区别) 2. 解析/语法分析 3. 代码生成<br/>
1 分词/词法分析：
  var a = 1 会被分成：var、a、=、1<br/>
2 解析/语法分析
  然后一个一个节点“制作”<br/>
3 代码生成 <br/>

用通俗的话对上边进行一个解释，当引擎需要运行以上代码时，它会去找编译器。编译器会先将代码分解，然后询问作用域内是否有一个叫做a的变量。没有的话它就自己建立一个，然后编译器在将2赋值给a 最终代码完成。那么作用域又是做什么的？它其实就是将编译器产生的变量组成一系列查询规则，并确定有的地方的代码可以访问，有的地方你是访问不了的。<br/>
因此，作用域会一层套一层从最里边开始。每次在找变量的时候，先从里边开始找找，渐渐到最外部。因而形成了一个叫做作用域链的规则。<br/>
## 3 函数作用域与块作用域
``` javascript
function foo(a) {
	var b = 2

	function bar() {

	}

	var c = 1=3
}
``` 
上述代码中，b、c、bar()是在同一个作用域。不过当b、c前边不加var，那它就从这个函数中“飘”出去了,在函数外部也是可以访问到它们的。<br/>
但是呢，这里还是有一个问题，在外边的这个函数它的名字是foo(),有时候我们函数写的多了，或者引用别人的框架时很容易名字发生冲突。因而一个叫做“匿名函数”的东西出现了。<br/>
举个例子：

``` javascript
(function foo() {
	var a = 3
	console.log(a)
})()  // 这个括号是为了调用
``` 
foo被限制在括号内使用，对于括号外边它不会影响别人，别人也不会影响它。这种行为类似将自己藏起来，对你我都好。<br/>
经常使用的匿名函数：<br/>
``` javascript
setTimeout (function() {
	console.log("nihao")
}, 1000)
``` 
将整个函数做成参数传递给setTimeout，形成回调。<br/>

## 4 块作用域
``` javascript
for(var i = 0; i < 5; i++) {
	console.log("guo")
}
console.log(i)
``` 
这里我们在外部访问i,仍旧可以访问到。并且不会报错，只是会返回最后一次i的值。这就说明for循环是没有作用域的。可能你觉得这没有什么问题，但是但是当我们在
写很多循环的时候，就会出现互相干扰的情况。你可能会去赋值另外一个变量类似j、k、l等等。不过ES6帮助我们解决了这个问题，在ES6中引入了一个叫做let的关键字，它会将作用域劫持下来。
``` javascript
for(let i = 0; i < 5; i++) {
	console.log("haha")
}
console.log(i)
```
这里访问i，系统会报错。<br/>
## 5 提升
``` javascript
a = 2 
var a 
console.log(a) // 输出什么呢？ 报错吗？或者是undefined？
```
然而这段代码既没有报错，也没有出现undefined。而是输出了一个2,有人可能会想这是为什么？其实也就是跟我们之前讲的编译器有关系了。上述代码实际处理过程会
变成下边这样：
``` javascript
var a 
a = 2
console.log(a)
```
编译器会将变量的声明提到赋值的前边，因而最后不会报错。在js中，函数也会出现这种情况，我称为它为“特性”。
``` javascript
foo()
function foo() {
console.log(a) // undefined
var a = 2 
}
``` 
由于函数声明会被提升，因为函数是可以执行的，由于函数内部的代码也是出现了变量提升，因而最后输出undefined 不过有个细节需要注意下，我们在声明函数时还可以使用函数表达式，上边的代码做一个小小的修改就变成下边的啦：
``` javascript
foo()
var foo = function() {
console.log(a) // undefined
var a = 2 
}
``` 
此时，就会出现报错。
## 6 闭包
讲了这么多铺垫，终于到了我们的主角--闭包。按照惯例，我需要给闭包一个专业名词，或者一段专业术语。“当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数在当前词法作用域之外执行。” 不过，我还是希望通过一个通俗的解释来说明什么是闭包。网上有一段很好的解释：我把我家的钥匙给你了。我家一直在那里，你只要有钥匙什么时候都可以开我家门。看下边代码:
``` javascript
function foo() {
	var a = 2 
	function bar() {
		console.log(a)
	}
	return bar // 相当于把钥匙暴露出去
}
var baz = foo()
baz()  // 2 
```
为什么要写闭包呢？
所谓存在即合理，就好比上述代码一样。我们想在外部访问到内部的a,这可不是那么容易的。因为产生了闭包这种做法。当然，闭包还有一种作用是让这段代码一直存在于内存中，因为js有着一种特殊的垃圾回收机制，我会在之后的文章中进行一个讲解。我们有时候想让代码一直存在，因而我们需要使用闭包。看下边的代码：（此段采用自阮一峰老师的博客）
``` javascript
function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
var result=f1();
result(); // 999
nAdd();
result(); // 1000
``` 
在第一次调用过后，n是999并且并没有被销毁，而是继续存在于内存中。在下边我们对它进行自加一，然后在输出发现它变成了1000.为什么会出现这种情况呢？<br/>
原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。<br/>
这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。<br/>
1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br/>
2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。<br/>
不过，网上有人对闭包是否造成内存泄漏各有各的说法，因为毕竟现在的浏览器早已经不是当年了。我之后会在有关内存的问题上写一些测试，到时候在更新在github上。这会要出去吃饭呀。<br/>
完 
